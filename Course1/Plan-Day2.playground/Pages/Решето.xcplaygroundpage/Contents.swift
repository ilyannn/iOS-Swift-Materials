//: [Предыдущая страница: Начало](@previous)

//: # [Решето Эратосфена](https://ru.wikipedia.org/wiki/Решето_Эратосфена)

//: ## Фильтры

//: Оператор `%` это математическая операция взятия по модулю.
func не_делится_на_2(number: Int) -> Bool {
    return number % 2 != 0
}

//: Примеры: некоторые числа делятся на 2, а некоторые нет.
не_делится_на_2(0)
не_делится_на_2(1)
не_делится_на_2(2)
не_делится_на_2(3)

//: Функции также можно определить оператором `let`.
//: При этом тип функции определяется с помощью стрелки `->`, а значение функции с помощью фигурных скобок.

let не_делится_на_3: Int -> Bool = { number in
    return number % 3 != 0
}

//: Попробуем применить эти функции как фильтр. 

//: *Напоминаем, что просмотреть большой массив можно нажав на знак `+`, который появится если навести мышку на значение справа.*

(1..<100).filter(не_делится_на_2).filter(не_делится_на_3)


//: Короткая форма описания функции: имя аргумента можно опустить, как и круглые скобки вокруг фигурных.

(1...100).filter(не_делится_на_2).filter(не_делится_на_3).filter({ number in 
    return number % 5 != 0
}).filter { $0 % 7 != 0 }


//: Вместо того, чтобы определять отдельно функцию для 2 и для 3, давайте сделаем универсальное определение. В данном случае мы сделали функцию, которая возвращает функцию!

func не_делится(на число:Int) -> (Int -> Bool) {

//: У нас есть возможность использовать или полную форму определения функции или короткую.  Короткая форма в других языках называется *lambda*-форма. В Swift не нужен специальный оператор для определения функции – просто фигурные скобки.
    
    //    func результат(тестируемый: Int) -> Bool {
    //        return тестируемый % число != 0
    //    }
    //    
    //    return результат
    
    return { $0 % число != 0 }
}

//: Работает вот так:

не_делится(на: 5)(500)
не_делится(на: 10)(500)
не_делится(на: 55)(500)

//: Попробуем просеять числа с помощью фильтров для 2, 3, 5 и 7. Получатся простые, по крайней мере до 121.

let простые_от_11_до_120 = (2..<120).filter(не_делится(на: 3)).filter(не_делится(на: 5)).filter(не_делится(на: 7)).filter(не_делится(на: 2))

//: Англоязычные имена вызывают у Xcode меньше проблем.
let hasRemainder = не_делится

//(2...100).filter(hasRemainder(на: 2)).filter(hasRemainder(на: 3)).filter(hasRemainder(на: 5))


//: ## Операторы языка

//: Наша следующая задача – написать функцию просеивания массива. Ее входные и выходные данные – массив целых чисел. Функция должна взять первое число, а также добавить то, что получится если отфильтровать по нему массив и просеять рекурсивно.

//: Мы используем `.first` чтобы получить первый элемент, и мы видим по ее типу `Int?`, что эта функция не всегда возвращает элемент. Значит, нам надо обработать два варинта – массив без элементов (то есть пустой) и массив с элементами.

func просеять(массив: [Int]) -> [Int] {
//: Вариант с оператором, который есть только в Swift: **`guard`-`else`**.
    
//    guard let первое = массив.first else { return [] }
//    let часть = просеять(массив.filter(не_делится(на: первое)))

//: Вариант с оператором, который есть во всех языках: **`if`-`else`**. Но именно в Swift есть форма if let, которая позволяет не только проверить, что в массиве есть элементы, но и сразу вытащить первый:

//    if let первое = массив.first {
//        let часть = просеять(массив.filter(не_делится(на: первое)))
//        return [первое] + часть
//    } else { 
//        return [] 
//    }

//: Вариант с оператором **`switch`-`case`**. В Swift результат работы функции `.first` может быть одним из двух: `None` или `Some`. Такой тип определяется с помощью **`enum`-`case`**.
    
    switch массив.first {
    
    case .None: 
        return []

    case .Some(let первое): 
        let часть = просеять(массив.filter(не_делится(на: первое)))
        return [первое] + часть
        
    }
}


//: Ну и посмотрим на результат:
просеять(Array(2...100)).maxElement()

//: Вот так можно написать противоположную функцию:

func делится(на число:Int) -> (Int -> Bool) {
    return { $0 % число == 0 }
}


//: ## Генерики

//: Попробуем написать функцию, которая применит два фильтра: сначала один, потом второй. Получатся, у этой функции будет два параметра типа `Int -> Bool` и такой же результат.

//: Но мжно сделать еще интереснее: пусть эта функция работает для фильтров любых типов, то есть `T -> Bool` где `T` - вообще любой тип. Это называется *[Generic programming](https://en.wikipedia.org/wiki/Generic_programming)* и есть также в C# и других продвинутых языках (в C++ это называется *шаблоны*, *templates*)

func +<T>(a: (T -> Bool), b:(T -> Bool)) -> (T -> Bool) {
    func ab(x: T) -> Bool {
        let результатA = a(x)
        let результатB = b(x)
        return результатA && результатB
    }
    return ab
}

//: Примеры сложения фильтров (наверное надо было назвать операцию `&&`):

//let результат10 = (1...200).filter(делится(на: 2) + делится(на:5)) 
//результат10
//
//результат10    == (1...200).filter(делится(на: 10))

let триФильтра = делится(на: 2) + делится(на:5) + делится(на:7)

let набор = [2, 3, 7, 11]

let набор_фильтр = набор.map(делится).reduce({ _ in true }, combine: +)

[0, 15, 2*3*7*11 * 20, 100, 345, 345943509].filter(набор_фильтр)


//: [Следующая страница: Поисковик](@next)


