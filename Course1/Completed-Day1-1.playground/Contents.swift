//: *Если вы видите слева от этой надписи символы слэша и двоеточия, то можно выбрать в меню Editor -> Show Rendered Markup и увидеть красивый текст.*

5 + 3
67 - 89
567 * 6586


//: *Вы можете перейти на другую страницу в playground, выбрав ее слева в навигаторе. Если навигатора не видно, нажмите `cmd + 1`, а для скрытия `cmd + 0`*

//: ## Калькулятор
//: Мы можем использовать playground как интерактивный калькулятор.

5 + 6

1.2 + 1.1

(4+5)-2

65.5 * 99



5 * 5

let a = 5
let b = 5.0






//: Целые и дробные числа компилятор воспринимает по-разному.

33

33.0

//: Для целых чисел применяется целочисленное деление.

33 / 2

33.0 / 2

let результат = 57 / 5
результат

результат + результат

Double(результат) + 1.0

//: Команда `let` устанавливает связь между именем и значением.
//: Имя можно писать в любом алфавите, но есть баги – Xcode не всегда покажет подсказку.


let price_€ = 199.99 // Alt + Shift + 2 ⌥⇧2

let €к₽ = 65.5
let стоимость_в_₽ = price_€ * €к₽


//: ## Типы в Swift
//: Массивы определяются с помощью квадратных скобок.

[56, 78, 56]

[5, 6, 7]

//: При определении массива Swift догадывается, что 7 надо воспринять как дробное число.

[6.5, 5.1, 7] + [10.5]


//: У массивов есть своя операция сложения (но нет умножения, вычитания или деления!)

let numbers:[Int] = [56, 22, 31] + [40]


//: ## Типы
//: Каждое значение в Swift имеет определенный тип, который можн указать явно. Как и во многих других языках программирования, дробный тип называется `Double`.

let Целый: Int = 33
let Дробный: Double = 33.5

//: Массив должен быть однородным
let Массив_целых: [Double] = [3, 2, 3]
let Массив_дробных: [Double] = [Дробный, 2, Дробный]


//: ## Функции
//: Для определения функции используются ключевые слова `func` и `return`.
//: Надо знать заранее тип.

func удвоить(число: Int) -> Int {
    return число * 2
}

func квадрат(number: Int) -> Int {
    return number * number
}

func утроить(число: Int) -> Int {
    return число * 3
}

// Взять точку x, умножить на k и добавить c
func scale(factor k:Double = 1, const:Double = 0, x: Double) -> Double {
    return k * x + const
}

func scaleNoNames(k:Double, _ c:Double, _ x: Double) -> Double {
    return k * x + c
}

func scaleByFactor(k:Double, const:Double, x: Double) -> Double {
    return k * x + const
}

scaleByFactor(5, const: 10.0, x: 5)

scale(factor: 3, const: 10, x: 5)
scale(factor: 10, const: 3, x: 5)

scaleNoNames(2, 5.5, 10)

scaleNoNames(1, 2, 3)

scale(factor: 1.0, const: 0.0, x: 10.5)

scale(factor: 2, x: 10)

// smalltalk
// [drive to: school in: my_car speed:60km/h]
//: Можно применять функции: математическая нотация f(x)
утроить(56)
удвоить(10)
квадрат(15)

квадрат(удвоить(2)) + удвоить(100)


//: Можно определить функцию с тем же именем, но другими типами – компилятор сам догадается, какую из них вызывать.

func удвоить(число: Double) -> Double {
    return число * 2
}


func удвоить(массив: [Int]) -> [Int] {
    return массив + массив
}

[1, 3, 5]

удвоить([1, 6, 7, 8])

//: **Вопрос:** как сделать в Swift так, чтобы в массиве были одновременно строки и числа.
//: Один из способов – определить новый тип "Строка или Число". Не во всех языках есть такой тип!

//enum Тип {
//    case Число(число: Int)
//    case Строка(строка: String)
//    case Дробное(дробное: Double)
//}
//
//let общий_swift: [Тип] = [Тип.Число(число: 4), Тип.Число(число: 5), Тип.Строка(строка: "строка")]

//: ## Оператор import
//: Оператор `import` делается только один раз. `Foundation` – базовые вещи, которые нужны в каждом приложении OSX или iOS.

import Foundation

//: Как дополнительный бонус, после импорта компилятор начинает понимать, что число и строка могут оба быть приведены к типу `NSObject`.

let общий:[NSObject] = [4, 5, "строка"]

let объект: NSObject = 5

//: Давайте поиграем с тригонометрическими функциями. В `Foundation` значение π называется так:

cos(M_PI)

//: Но можно опрелить свое имя. π вводится alt + P (в американской раскладке)

let π = M_PI

//: Напомним про тригонометрические функции. Заметим, что математически cos(π/3) точно равен 0.5, но компилятор честно считает – и имеет неточность в последнем знаке.

sin(π/3)
cos(π/3)


//: Как повернуть вектор (10, 0) влево на π/4:

let новый_х = 10 * cos(π / 4)
let новый_y = 10 * sin(π / 4)

//: Длина вектора остается той же самой. Если бы это можно было нарисовать...

let Длина_вектора = sqrt(новый_х * новый_х + новый_y * новый_y)

//: ## Объектная нотации
//: Функция – это глагол в S-V-O. В большинстве индоевропейских языков сначала идет субъект, потом глагол. Вообще в мире так говорит большее число людей чем с другими порядками.
numbers.sort()

//: В C++ 17 сейчас тоже будет чаще применяться объектная нотация.
//: Для интересующихся – [статья Bjarne Stroustrup на ту тему](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4174.pdf).

numbers.sort()
numbers

let sorted = numbers.sort()

//: Примеры функций – `.maxElement()`
numbers.maxElement()

numbers.maxElement()
numbers.minElement()

numbers.sort().minElement()
numbers.sort().first

numbers[0]
numbers.first

let reverse = numbers.reverse()
reverse.first
reverse.count
Array(reverse)

Array(numbers.sort().reverse())
//: На самом деле `first` это тоже функция, но определенная без скобок. Почему и как – мы узнаем потом.
numbers.first
numbers.minElement()

2.2354765900.description
