# Важность разделения кода 

То что мы делаем очень сложно и в MVC есть проблема больших контроллеров: сложный View Controller это то, куда часто сливается весь код – и получаются тысячи строк в одном файле! Надо попробовать упорядочить хаос в архитектуре мобильных приложений. 

> *Замечание: Activity в мире андроида во многом аналогичен понятию View Controller, и к нему не применимы большинство полезностей, которые здесь будут обсуждаться. Совпадение названия не является случайным в том смысле что мы описываем похожие явления, но описываем совсем по-разному.*



# Примеры существующих подходов 

На тему архитектуры iOS приложений есть довольно много текста, например первый выпуск `objc.io`, *[Lighter view controllers](http://www.objc.io/issues/1-view-controllers/)* был посвящен именно выделению кода из View Controller’ов. Несложно научиться выделять  части отображения таблицы, или вещи относящиеся к части View в отдельные классы. 

Это позволит нам сделать простой и красивый код для приложений, в которых есть только эти объекты.

Но, у нас сейчас намного более сложные приложения чем просто таблицы: нужны загрузки из сети, изменения размера, notifications, Bluetooth и так далее. 

[Использование Store в рамках MVCS](http://programmers.stackexchange.com/questions/184396/mvcs-model-view-controller-store): выделяет часть модели в отдельный объект. Это правильно и таким образом можно вынести, например, код импорта в модель, но остаётся все связанное с действиями пользователя или событиями, а также вопрос о том, кто управляет событием начала импорта в модель? 

Кроме того, остаётся проблема инициализации и передачи Store. Например, в этом ответе 

> I will often create a singleton manager class that handles setting up the Core Data stack, and deals with all of the fetching/saving that is involved with the stack.

Проблема: где живёт логика создания модели? Не случайно это часто синглетон. Тем не менее, хозяин этой логики должен быть. Например app delegate мог бы выступить в роли владельца. Конечно обычно мы не имеем доступа к нему и не можем легко  передать от него данные, и люди создают синглетон. 

На самом деле при использовании View Controller как главных объектов мы упираемся в особенности архитектуры приложений iOS, про что расскажет следуюший раздел.


# Кто управляет управляющим?

View Сontroller создается системой и обязан иметь стандартный инициализатор. Это особенно странно смотрится в Swift 

Пример: редактирование поста. Мы хотели бы передать пост как let (так, что он будет неизменяемым – пользователь не может начать редактировать один пост, а закончить редактировать другой!), но это не согласуется с идеей рисования экрана в Storyboard:

    class PostViewController {
        let editingPost: Post
    
        // Мы создали init для View Controller, в котором 
        // обязательным является передача редактируемого объекта.
        init(post: Post) {
            editingPost = post
            ...
        }
    
        // Но система автоматически вызывает стандартный init(nibName: bundle:)    
    }

Напрямую в коде можно было бы создать объект View Controller, 

    PostViewController(post: somePost)

но это принципиально не работает со Storyboard, который всегда использует `init(coder:)`. Кроме того, мы таким образом лишаемся возможности нарисовать для PostViewController два разных интерфейса в разных сторибоардах. 

Продолжим дальше: что если этот view требуют некоторого сложного расположения на экране и загрузки картинок, так что мы хотели бы оставить его для изменения другого поста, не скрывая View и используя тот же PostViewController. С учетом кода выше, нам надо будет добавить возможность изменения editingPost:

    class PostViewController {
        var editingPost: Post
        ...
    }
    
Допустим теперь, что при открытии приложения мы должны сначала загрузить Post из облачного аккаунта. Как часть этого процесса логично было бы показать пользователю пустой интерфейс, то есть интерфейс, построенный PostViewController, которому передана информация об отсутствии объекта:

    class PostViewController {
        var editingPost: Post?
        
        // init(post: Post) { 
        // ^^^ отказываемся от этого инициализатора
    }
  
Итак, мы вернулись на начальную позицию. Это логично: неотъемлемое свойство VC состоит в том что он в первую очередь контролирует View. Мы не должны ломать систему: здесь понятно что при управлении View пост вполне может меняться, или оказываться `nil`. 

Похоже, применяя для управления логикой View Controller мы не провели границу между отображением view и логикой работы с нашими объектами – так что объект, который приспособлен для одной цели получается не приспособлен для другой. Иными словами, мы нарушили [Single Responsibility Principle](http://blog.codinghorror.com/curlys-law-do-one-thing/)

Значит, логически управление экраном и управление логикой работы приложения должны относится к разным объектам. Давайте попробуем набросать как все может выглядеть. 

Если мы предполагаем что View Controller создается системой автоматически, то один из вариантов настройки Activity состоит в передаче его в init:

    class PostActivity {
        // let, как и полагается
        let editingPost: Post
        
        // Во время работы activity ее view controller не меняется 
        let managedController: PostViewController
    
        init(post: Post, vc: PostViewController) {
            editingPost = post
            managedController = vc
            ...
        }
    }    

Теперь мы можем создавать `PostActivity` ровно в тот момент когда мы готовы. 



# Что нужно от Activities? 

Что мы получаем от создания отдельного объекта? Теперь можно применить паттерн Builder: при создании Activity не обязательно запускать её сразу. И наоборот, после того как activity закончилась и не отображается на экране, можно оставить её, например, для получения данных результата. 

Давайте выделим отдельный метод start и свойства, которые помогут понимать статус Activity. Кроме того, до начала и после окончания действия активности ей уже не нужен контроллер, поэтому настраивать его можно снаружи.

	class PostActivity {
		let editingPost: Post
		
		weak var managedController: PostViewController?
		
		init(post: Post) {
			editingPost = post
			...
		}
		
		private(set) var finished = false
		private(set) var executing = false
		
		func start() {
			executing = true
			precondition(managedController) 
			managedController?.editingPost = editingPost
			...
		}
	
	   func weAreDone() {
	       ...
	       executing = false
	       ...
	   }
	}    

Наличие методов `start` и свойств `executing` и `finished` подсказывает нам, что что активность можно сделать асинхронной операцией в формальном смысле, наследуя её от `NSOperation`.

Чтобы правильно сделать это, потребуется некоторый довольно стандартный код создания асинхронных операций, который имеет смысл просто вынести в суперкласс:  

	class Activity: NSOperation {
		// Здесь опущен getter
		override var asynchronous: Bool { return true }
     
		func start() {
			executing = true
			main()
		}
	
		func weAreDone() {
	       		...
			executing = false
	      		...
	   	}
	   ...
	   }
	
Так что оставшийся код содержит только логику, относящуюся к особенностям PostActivity:

	class PostActivity: Activity {
		let editingPost: Post
		
		var managedController: PostViewController!
		
		init(post: Post) {
			editingPost = post
			...
		}
		
	   override var ready: Bool {
           return super.ready && managedController != nil
	   }
	
	   func main() {
			managedController.editingPost = editingPost
	      ...
      }	
	}   

Нам потребовался некоторый рефакторинг, но мы получили бесплатно много полезностей. С нашей PostActivity теперь можно сделать такие вещи:

* положить в последовательную очередь `NSOperationQueue` так чтобы несколько операций выполнялись по очереди
* поставить ей `completionBlock`, который будет выполнен при завершении
* проверить стадию выполнения (заметим что метод ready определен так, что вызов `start()` возможен только после установки `managedController`)
* вызвать `cancel` (который пока не обрабатывается в коде выше)

# Передача состояния

Поможет ли эта структура нам в передаче общих данных? Давайте для примера предположим что наш `Post` живет в модельном слое, доступ к которому контролируется через `ModelManager`. Мы хотим чтобы `PostActivity` имел доступ к его инстанции. Один способ это сделать выглядит так:

    class PostActivity {
    
		... doStuff() {
			...
            let modelManager = ModelManager.sharedModelManager()
            modelManager.save(...)
			... 
        }
    }
    
Есть много статей, объясняющих недостатки этого метода; если они неочевидны, то остальная часть статьи, вероятно, будет Вам неинтересна и её лучше не читать. 

Чтобы передать `modelManager` можно, например, сделать его обязательным параметром в инициализаторе, или, по аналогии с `managedController`, дать возможность настроить его на этапе конфигурации операции между `init` и `start`, например:

    class PostList {

     ... 
     let postActivity = PostActivity(post: selectedPost)
     postActivity.modelManager = modelManager.createTemporaryChild()
     ...
    }
    
если наша модель поддерживает создание временного контекста, еще не сохраненного на диск (как, например, контексты Core Data). Таким образом, одна и та же активность может быть сконфигурирована для работы во временном или постоянном контексте - и сама она не должна думать о таких вещах.



# Activity Tree

Вызывающие друг друга активности таким образом организуются в дерево. 

Посмотрим, какие еще примеры передаваемых состояний могут нам потребоваться. Например, если мы хотим сохранить общий стиль приложения, возможно что мы хотим производить настройку экрана с помощью менеджера стиля каждый раз при отображении View Controller’а. Далее, в приложении, работающем с передачей данных другому работнику, такому как сервер в облаке, может потребоваться передача состояния соединения с работником.

Благодаря нашему разделению `init` и `start`, не обязательно задавать все эти параметры в конструкторе. Мы можем вынести эти параметры в конфигурируемый метод:

    class OurActivity: Activity {
        var styleManager: StyleManager
        ...
    
        func startActivity(activity child: OurActivity) {
            child.styleManager = styleManager
            child.serviceAPI = serviceAPI
            ... 
            child.start()
        }
    
    }
    
Недостаток этого метода, тем не менее, состоит в том что теоретически конфигурируемый шаг – настройка новой активности – становится неконфигурируемым. Как назвать конфигуратор запуска новых активностей?
   


# Activity Stack as a Monad

Давайте предположим для простоты что наши экраны устроены последовательно и, таким образом, наши активности организуются в стэк (или, если у нас присутствует таббар, получается что у нас не может понадобиться сделать так чтобы в разных табах одновременно работало несколько Activities)

Наша структура тогда формализуется как 

    class ActivityStack: ActivityUserInterfaceFacade {
        var stack: Stack<Activity> = []
    
        func startActivity(activity child: OurActivity) {
            child.serviceAPI = serviceAPI
            child.userInterfaceFacade = self
            ... 
            stack.pushObject(child)
            child.start()
        }
    
        func displayViewController(vc:UIViewController) {
            styleManager.configure(viewController: vc)
            currentVC.presentViewController(vc, animated: true)
            currentVC = vc
        }
    }
 
В данном примере мы также добавили метод, с помощью которого Activity может вывести экран в том случае если она запущена без указания управляемого экрана. Вообще, если мы потребуем чтобы активность не отображала View Controller’ы самостоятельно, а проводила такие действия через `ActivityStack`, то можно убрать у Activity необходимость знать о наличии стилей.

Когда мы передаем инстанцию `ActivityStack` для обратного вызова из `Activity`, нам, разумеется не нужно передавать все возможности стэка; мы можем ограничить передачу протоком, описывающим что может сделать инстанция активности; этот протокол назван `ActivityUserInterfaceFacade`.

(пока не успел рассказать про монады, но концептуально они могут, например, добавлять состояние к чистых функции в Haskell)

Мы можем думать про методы активности как про чистые функции, а про стек как про монаду, добавляющую состояние, в данном примере `serviceAPI` и `userInterfaceFacade`. 



# Другие достоинства активностей

- Активность имеет ограниченные знания об остальных частях приложения. 
- Можно тестировать отдельно одну активность, задав mock объект за фасадом.  
- Активность может работать как scratchpad: если мы не знаем куда помещать код, он идёт туда а потом с помощью рефакторинга выносится на более правильное место. 
- Активности естественным образом организуются в стек, даже если экраны содержат таббар. 
- К активности можно подтянуть один Storyboard на 1-3 экрана. Такое разделение будет соответствовать понимаю логики продукта. 
- Активности ничто не мешает управлять сразу несколькими окнами: что если выйдет iPhone с 3d-голограммами?
- Активность может переехать на сервер и оставить яблочный  девайс в качестве тонкого клиента. И наоборот, активность может быть перенесена с сервера. 



# Важные вопросы по тексту
- Переименовать Activity в что-нибудь? Может запутать людей из Андроида.
- Написать про монады. Формально это не монада, может попробовать доработать?
- Надо бы пример, скажем переработав стандартный яблочный шаблон с Core Data.
