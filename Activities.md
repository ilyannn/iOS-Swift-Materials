# Важность разделения кода 

То что мы делаем очень сложно и в MVC есть проблема больших контроллеров. Надо попробовать упорядочить хаос в архитектуре мобильных приложений. 


# Примеры существующих подходов 

Lighter view controllers — например выделение части отображения таблицы. Но, у нас сейчас намного более сложные приложения чем просто таблицы: нужны загрузки из сети, изменения размера, notifications, Bluetooth и так далее. 

Использование Store в рамках MVCS: выделяет часть модели в отдельный объект. Это правильно но остаётся все связанное с действиями пользователя или событиями. 

Кроме того, остаётся проблема инициализации и передачи Store. Например, в этом ответе 

> I will often create a singleton manager class that handles setting up the Core Data stack, and deals with all of the fetching/saving that is involved with the stack.

http://programmers.stackexchange.com/questions/184396/mvcs-model-view-controller-store

Проблема: где живёт логика создания модели? Не случайно это часто синглетон. Тем не менее, хозяин этой логики должен быть. Например app delegate мог бы выступить в роли владельца. Конечно обычно мы не имеем доступа к нему и не можем легко  передать от него данные, и люди создают синглетон. 


#Who controls a controller?

View controller создается системой и обязан иметь стандартный инициализатор. Это особенно странно смотрится в Swift 

Пример: редактирование поста. Мы хотели бы передать пост как let, но это невозможно. 

Тем не менее это логичное и неотъемлемое свойство VC так как VC в первую очередь контролирует View. Мы не должны ломать систему: здесь понятно что при управлении View пост вполне может меняться, даже можно не скрывать View и использовать тот же PostViewController. Видно что логически управление экраном и управление логикой должны относится к разным объектам. 


# Что нужно от Activities? 

- Активность это асинхронная операция в формальном смысле. Её можно положить в очередь NSOperationQueue или поставить ей successBlock. 
- Активность имеет ограниченные знания об остальных частях приложения. 
- Можно тестировать отдельно одну активность, задав mock объект за фасадом.  
- Активность может работать как scratchpad: если мы не знаем куда помещать код, он идёт туда а потом с помощью рефакторинга выносится на более правильное место. 
- Активности естественным образом организуются в стек, даже если экраны содержат таббар. 


#Activity Stack as a Monad

Мы можем думать про активность как про чистую функцию, а про стек как про монаду, добавляющую состояние. 


# Няшечки 
- К активности можно подтянуть один Storyboard на 1-3 экрана. Такое разделение будет соответствовать понимаю логики продукта. 
- Фасад UI может настраивать экраны согласно общему стилю приложения. 
- Активности ничто не мешает управлять сразу несколькими окнами: что если выйдет iPhone с голограммами?
- Активность может переехать на сервер и оставить яблочный  девайс в качестве тонкого клиента. И наоборот, активность может быть перенесена с сервера. 

